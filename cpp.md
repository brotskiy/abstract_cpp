# 1. Переменные

## 1.1. Период жизни переменной

Любая переменная в С++ обладает одним из следующих возможных видов хранения:

+ **automatic** - *автоматическое хранение*; память под такую переменную выделяется при каждом выполнении содержащего её блока кода, а освобождается при завершении данного блока;
+ **dynamic** - *динамическое хранение*; память под такую переменную выделяется явным вызовом оператора `new()`, а освобождается явным вызовом оператора `delete()`;
+ **static** - *статическое хранение*; память под такую переменную выделяется и затем освобождается ОДИН раз за всё время выполнения ПРОГРАММЫ - другими словами, ВО ВСЕЙ ПРОГРАММЕ существует ЕДИНСТВЕННЫЙ экземпляр такой переменной;
+ **thread** - *хранение уровня потока*; память под такую переменную выделяется и затем освобождается ОДИН раз за всё время выполнения конкретного ПОТОКА, в котором она существует - другими словами, в КАЖДОМ ПОТОКЕ существует СОБСТВЕННЫЙ, ЕДИНСТВЕННЫЙ ДЛЯ ДАННОГО ПОТОКА экземпляр такой переменной.

*Автоматическим хранением* обладают **локальные переменные**. Они располагаются на *стеке* - следовательно, каждый поток, выполняющий некоторую заданную функцию (её блок кода) на *своем собственном стеке*, будет иметь собственный экземпляр заданной локальной переменной. Если им в момент создания для локальной переменной НЕ было задано начальное значение, то она останется *неинициализированной*.

*Динамическим хранением* обладают **динамические переменные**. Они располагаются в общей для всего процесса области *кучи*. Если им в момент создания для динамической переменной НЕ было задано начальное значение, то она останется *неинициализированной*.

Особенности расположения в памяти и инициализации переменных со *статическим хранением* и *хранением уровня потока* будут рассмотрены далее.

Важно помнить, что все переменные располагаются в *едином* адресном пространстве процесса, в котором работают все его потока - независимо от типа хранения переменной её адрес может свободно передаваться между потоками путем использования различных средств языка. Однако крайне важно следить за временем жизни переменной и исключить возможность обращения к освобожденной памяти.

## 1.2. Статическое хранение

**Нелокальными переменными** называются:

+ **глобальные переменные**;
+ **переменные в пространствах имен**;
+ **статические переменные-члены класса**.

*Статическим хранением* обладают следующие переменные:

+ **нелокальные переменные**;
+ **локальные статические переменные**.

Как уже было сказано, память под переменные со *статическим хранением* выделяется и освобождается ОДИН раз за время выполнения всего процесса, а в программе существует ЕДИНСТВЕННЫЙ экземпляр такой переменной.

Пример:

```Cpp
int var1;
namespace nsp { int var2; }
class cls { static int var3;};

void func { static int var4; }
```

Инициализация значения **нелокальной переменной** происходит ДО вызова `main()`, а уничтожение её значения происходит ПОСЛЕ завершения `main()`.

Инициализация значения **локальной статической переменной** происходит при ПЕРВОМ ВЫПОЛНЕНИИ инструкции её *определения* вследствие вызова содержащей её ФУНКЦИИ - при последующих вызовах функции инструкция определения пропускается. Уничтожение локальной статической переменной происходит ПОСЛЕ завершения `main()`.

Общая схема инициализации переменных со *статическим хранением* выглядит следующим образом:

1. На этапе компиляции программы для каждой переменной со статическим хранением выполняется **статическая инициализация**. Существует 2 формы статической инициализации:

   + **constant initialization** - выполняется, если переменная заполняется *константным выражением*, значение которого известно на этапе компиляции;
   + **zero-initialized** - выполняется, если значение переменной не задано, или его невозможно определить на этапе компиляции; в программе *предварительно* считается, что такие перемененные имеют нулевое значение.

    В результате инициализированная переменная записывается в *секцию данных* ELF-файла программы. Инициализированная *константа* `const` может на усмотрение компилятора попаться в *секцию кода* программы (помечается в процессе как "только для чтения").

    Существуют ключевые слова, указание которых гарантирует инициализацию переменной во время компиляции программы:

    + `constexpr` - инициализирует во время компиляции и накладывает на переменную `const`;
    + `constinit` -  инициализирует во время компиляции и НЕ накладывает `const`.

2. При запуске процесса в первую очередь происходит перенос *статически инициализированных* переменных со статическим хранением в *2 области данных* памяти процесса, в результате которого они получат либо константное, либо нулевое значение (для переменных, инициализатор которых не удалось посчитать на этапе компиляции, нулевое значение по-прежнему остаётся *предварительным*) - на жаргоне говорят, что в этот момент *завершилась их статическая инициализация*.

3. Затем начинает выполняться **динамическая инициализация** НЕЛОКАЛЬНЫХ переменных - **Ordered Dynamic Initialization**. Её порядок в рамках ОДНОЙ ЕДИНИЦЫ ТРАНСЛЯЦИИ определяется очередностью появлений в неё *определений* переменных. Взаимный порядок динамической инициализации нелокальных переменных из РАЗНЫХ ЕДИНИЦ ТРАНСЛЯЦИИ заранее определить НЕВОЗМОЖНО - он определяется результатом работы линковщика!

    Если динамическая инициализации нелокальной переменной прерывается *исключением*, то программа завершается `std::terminate()`!

4. Как уже было упомянуто, инициализация ЛОКАЛЬНОЙ СТАТИЧЕСКОЙ перемененной выполняется в течение первого вызова содержащей их функции. Если функция, содержащая локальную статическую переменную, одновременно вызывается в *нескольких потоках*, то гарантируется, что инициализация произойдет *однократно* в некотором *случайном* потоке.

   Если инициализация нелокальной статической переменной прерывается исключением после начала работы `main()`, то переменная считается не созданной и повторно конструируется при следующем вызове своей функции. Если же иключение было выброшено в тот момент, когда функция использовалась для динамической инициализации НЕЛОКАЛЬНОЙ переменной, то программа завершается `std::terminate()`!

## 1.3. Хранение уровня потока

Ключевое слово `thread_local` применяется к объявлению переменной со *статическим хранением* (любой из описанный *нелокальных* или *локальной статической переменной*), чтобы изменить её способ хранения на *уровень потока*. Это означает, что для каждого потока будет создаваться его СОБСТВЕННАЯ, ЕДИНСТВЕННАЯ ДЛЯ ДАННОГО ПОТОКА копия указанной переменной.

Инициализация *нелокальных `thread_local`*  переменных выполняется ДО начала работы *функции-потока*. Уничтожение данных переменных происходит после её завершения. Если инициализация прерывается *исключением*, то программа завершается `std::terminate()`!

Инициализация *локальных статических `thread_local`* переменных происходит в течение первого вызова содержащих их функций. Если инициализация прерывается исключением, то переменная может быть повторно сконструирована при следующем вызове функции. Если функция использовалась для инициализации нелокальной `thread_local` переменной, то программа завершится `std::terminate()`!

## 1.4. Инициализация статических переменных-членов

Инициализация статических переменных-членов класса имеет особенности - смотреть главу про Классы!

# 2. Функции

## 2.1. Объявление и определение функции

К функции нельзя обратиться в коде, если она не была предварительно *объявлена*. *Определение* функции - это объявление, содержащее тело функции.

Объявление функции должно содержать:

+ *тип возвращаемого значения*;
+ *имя функции*;
+ *список типов аргументов*.

Дополнительно могут быть заданы *имена аргументов*. Они не являются частью *сигнатуры функции* и могут отличаться от объявления к объявлению (или определению).

## 2.2. Передача аргументов

### 2.2.1. Аргументы-ссылки

Аргументы, представляющие собой **константную ссылку `const T&`**, могут принимать литералы, константы, переменные. Они также разрешают выполнение *преобразования типа* для фактического параметра - в этом случае перед вызовом функции будет создана *временная переменная* с временем жизни константной ссылки (т.е. до завершения функции).

Аргументы, представляющие собой обычную **ссылку `T&`** могут принимать только переменные, причем *преобразование типа* фактического параметра ЗАПРЕЩЕНО!

### 2.2.2. Аргументы-массивы

При передаче массива `T[]` в аргуент функции он всегда преобразуется в указатель на свой первый элемент `T*` - массив не может быть передан по значению.

## 2.3. Возвращение значения

Функция должна либо возвращать значение указанного типа `T` (для которого при необходимости выполняется *преобразование типа*), либо НЕ возвращать ничего, если она объявлена как `void`.

Функция, возвращающая значение, может полностью завершиться, так и не вызвав `return` - это называется **выпадением из функции**. Выпадение не запрещено компилятором и не вызывает ошибку времени выполнения, однако значения возвращаемого значения НЕ определено. Выпадение гарантированно приводит к ошибкам логики программы и НЕ должно в ней присутствовать.

Функция НЕ должна возвращать указатель либо ссылку на локальную переменную, уничтожаемую при завершении функции - это гарантированно приводит к ошибкам логики.

## 2.4. Перегрузка функций

**Перегрузка функции** - использование единственного имени для определения нескольких функций различных типов (на жаргоне их называют *перегрузками*). Данный механизм применяется для того, чтобы специфицировать поведение функции в зависимости от типа её аргументов.

На этапе компиляции для каждого вызова перегруженной функции *В ЕГО ОБЛАСТИ ВИДИМОСТИ* выполняется поиск такой её перегрузки, формальные параметры которой будут *наилучшим образом* соответствовать фактическим параметрам данного вызова. Определен следующий приоритет соответствия типов фактического и формального параметров:

1. Точное соответствие типов или соответствие, полученное *тривиальным преобразованием типов*: `T[] -> T*`, `T <-> const T`, функция в указатель на функцию;
2. Cоответствие, полученное *продвижением типов*: интегральным (`char -> int` и т.д.) или вещественным (`float -> double`);
3. Cоответствие, полученное *cтандартным преобразованием типов*: `int <-> double` и т.д. (допускаются *сужающие преобразования*), `Derived* -> Base*`, `T* -> void*`, `signed ints -> unsigned ints`;
4. Cоответствие, полученное *определенным пользователем преобразованием*: конструкторы и операторы преобразования;
5. Соответствие за счет многоточия `...` в объявлении функции.

Наиболее подходящей перегрузкой является та, *каждый* формальный аргумент которой соответствует фактическому аргументу вызова *не хуже*, чем аналогичный формальный аргумент любой другой перегрузки, и при этом *хотя бы для одного* аргумента соответствие *строго лучше*. Если не удаётся найти единственную наиболее подходящую перегрузку, то вызов считается **неоднозначным**, и происходит **ошибка компиляции**.

При разрешении перегрузки поиск выполняется только среди ОБЪЯВЛЕННЫХ К МОМЕНТУ вызова перегрузок. Порядок объявлений значения НЕ имеет.

**Механизм разрешения перегрузки НЕ пересекает границы областей видимости**. В разрешении перегрузки данного вызова НЕ участвуют перегрузки, объявленные в других областях видимости:

+ в других блоках кода (если блоки вложены, то внутреннее имя скрывает внешнее имя);
+ в других пространствах имен (если пространства имен вложены, то внутреннее имя скрывает внешнее имя);
+ в *родительских* по отношению к данному классах.

Чтобы ввести имя функции в текущую область видимости, позволить обращаться к ней без явного указания *квалификатора* `::` и тем самым разрешить ей участвовать в механизме разрешения перегрузки можно использовать `using`-директиву или `using`-объявление.

*Тип возвращаемого значения функции* при разрешении перегрузки НЕ учитываются - перегрузки одной функции могут иметь различный возвращаемый тип.

## 2.5. Спецификатор inline

**Спецификатор `inline`** указывает компилятору, что для функция явялется *встроенной* - для неё будет использоваться **внутреннее связывание**, однако компилятор самостоятельно решает, генерировать ли в каждом месте вызова функции её код, либо применять стандартный механизм вызова. Встроенная функция всё равно имеет свой собственный *уникальный адрес* в памяти процесса.

# 3. Пространства имен

## 3.1. using-объявления и using-директивы

Ключевое слово `using`, сопровождаемое именем сущности, имеет различающиеся по своему эффекту варианты использования:

+ **using-объявление для функции** вводит имя функции в текущую область видимости - *блок кода, класс или пространство имен* (включая глобальное) - и делает его доступным для использования без указания квалификатора `::`.

    Правила введения имени функции в область видимости:

  + в *блок кода* может быть введено имя функции из *пространства имен*. Вводимое имя НЕ должно совпадать с именем, напрямую объявленным в текущей области видимости - будет конфликт!

    ```Cpp
    // ... какое-то локальное окружение
    {
        using MySpace::myFunc;
    }
    // ... какое-то локальное окружение
    ```

  + в *пространство имен* может быть введено имя функции из *пространства имен* (включая *охватывающее*). Вводимое имя НЕ должно совпадать с именем, напрямую объявленным в текущей области видимости - будет конфликт!

    ```Cpp
    namespace MySpace1
    {
    void myFunc() {}
    }

    namespace MySpace2
    {
    using MySpace1::myFunc;
    }
    ```

  + в *класс* может быть введено имя функции из *родительского класса*. Вводимое имя *ИЗНАЧАЛЬНО* должно быть видно в дочернем классе (не должно находиться в `private`-секции родительского класса). Имя, напрямую объявленное в классе, имеет приоритет над именем, вводимым из базового класса, при их совпадении - введенное имя будет скрыто!

    ```Cpp
    class MyClassImpl
    {
    public:
        void myFunc() {}
    };

    class MyClass : private MyClassImpl
    {
        using MyClassImpl::myFunc;
    };
    ```

+ **using-директива** вводит имена *любых сущностей* указанного *пространства имен* в текущую область видимости - *блок кода или пространство имен* - и делает их доступными для использования без указания квалификатора `::`.

    ```Cpp
    namespace MySpace1
    {
    const int myConst = 45;
    void myFunc() {}
    }

    namespace MySpace2
    {
    using namespace MySpace1;
    }
    ```

Имена, *напрямую объявленные в текущей области видимости* или введенные *using-объявлением*, **ИМЕЮТ ПРИОРИТЕТ** перед именами, введенными *using-директивой*, и **СКРЫВАЮТ** их. Это позволяет, например, объединить с помощью директив несколько пространств в одном, а затем устранить все проявившиеся конфликты имен через using-объявления.

Наиболее часто using-объявления и using-директивы импользуется, чтобы позволить введенной функции участвовать в механизме разрешения перегрузки, а также чтобы при каждом использовании имени не указывать квалификатор (например, если он длинный).

## 3.2. Поиск имени функции

Если функция, объявленная в пространстве имен, вызывается в некоторой области видимости без указания *квалификатора своего пространства имен* `::` (и при этом она не была введена в текущую область через `using`), то поиск её объявления осуществляется в пространствах имен её аргументов. Это вызвано тем, что зачастую функции, принимающие пользовательские типы `class T`, определяется в тех же самых пространствах имен, что и эти пользовательские типы. При этом пространство имен должно быть видимым в данной области видимости, а объявление функции в нем должно существовать - правило, что имя (функции) должно быть объявлено до своего использования, никто не отменял!

Когда член класса вызывает функцию с некоторым именем, то другие члены того же класса или его родителей имеют приоритет над найденными функциями НЕ-членами.

# 4. Компоновка

Про имя сущности, доступное для использования только в той единице трансляции, в которой эта сущность определена, говорят, что оно **компонуется внутренним образом (internal linkage)**.

Про имя сущности, доступное для использования в различных единицах трансляции, отличных от той, в которой эта сущность определена, говорят, что оно **компонуется внешним образом (external linkage)**.

Следующие сущности, объявленные в глобальной области видимости или в пространстве имен, компонуются *внутренним образом*:

+ константы `const`;
+ выражения создания пседонимов `typedef`;
+ встроенные `inline` функции;

## 4.1. Правило одного определения (ODR)

Любая сущность должна быть *определена* в программе *ровно один раз*. Однако несколько определений *класса, шаблона или встроенной функции* могут существовать в качестве определения одной и той же сущности, если:

+ они находятся в различных единицах трансляции;
+ они идентичны лексема за лексемой (они записаны одинаково);
+ значение лексем идентично во всех единицах трансляции (их смысл одинаков).

# 5. Классы

## 5.1. Необходимая инициализация членов

Следующие типы объектов-членов класса должны быть явно инициализированы, т.к. не существует способа сделать это по умолчанию:

+ объект-член, являющийся константой;
+ объект-член, являющийся ссылкой;
+ объект-член, для которого не задан default-конструктор.

## 5.2. Инициализация статических членов

До С++11 при объявлении члена класса его можно было сразу инициализировать, если он являлся *статической константой интегрального типа*. Начиная со стандарта С++11, дополнительно в момент объявления можно инициализировать *нестатический* член *любого типа*.

Например:

```Cpp
class MyClass
{
    static const int i = 5;
    MyType v = MyType(6, 7);
};
```

Также даже если *статический константный интегральный член* инициализирован при объявлении, он всё равно должен быть один раз определен! (В реальности требуется определять только члены, для которых требуется обращение к их адресу, однако для избежания плохо отслеживаемых ошибок времени выполнения КРАЙНЕ рекомендуется делать это ВСЕГДА!)

Пример:

```Cpp
class MyClass
{
    static const MyType v1;
    static MyType v2;
};

const MyType MyClass::v1 = MyType(1, 2);
MyType MyClass::v2 = MyType(3, 4);
```

## 5.3. Копирование членов

*Default-copy-конструктор и default-copy-присваивание* просто копируют все нестатические члены класса (включая массивы и константы).

Default-copy-конструктор НЕ может быть сгенерирован, если некоторый нестатический член НЕ обладает copy-конструктором.

Default-copy-присваивание НЕ может быть сгенерировано, если некоторый нестатический член:

+ НЕ обладает copy-присваиванием;
+ является ссылкой;
+ является константой.

Если скопированный член являлся ссылкой или указателем, то в результате он продолжит ссылаться на исходную память - почти всегда это является ошибкой, и поэтому для таких случаев требуется явная реализация *глубокого копирования*.

## 5.4. Множественное наследование

Класс может иметь более одного родительского класса.

## 5.5. Разрешение неоднозначности вызовов функций

Следующие сведения справедлива как для *виртуальных*, так и для *затененных* функций.

Несколько родительских классов могут иметь функцию-член с одинаковым именем - каждый объект родительского класса, хранящийся в дочернем классе, будет содержать экземпляр своей функции.

Если обратиться по имени к данной функции (любой вариант ODR-use), то возможны следующие ситуации:

+ если данная функция определяется в дочернем классе, то будет экземпляр из дочернего класса;
+ если

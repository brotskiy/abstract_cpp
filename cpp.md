# 1. Статические переменные

**Статические переменные** размещаются в *области данных* процесса. Их время жизни не зависит от их области видимости - они уничтожаются своими деструкторами после возвращения значения из функции `main()`.

**Локальная статическая переменная**, расположенная в теле функции, создается в момент первого и единственного выполнения строки, содержащей её *определение* - при последующих вызовах функции инициализация данной статической переменной *пропускается*. При одновременном вызове функции *в различных потоках* невозможно сказать, какой именно поток инициализиет статическую переменную, однако гарантируется, что инициализацию выполнит только ОДИН поток.

# 2. Функции

## 2.1. Объявление и определение функции

К функции нельзя обратиться в коде, если она не была предварительно *объявлена*. *Определение* функции - это объявление, содержащее тело функции.

Объявление функции должно содержать:

+ *тип возвращаемого значения*;
+ *имя функции*;
+ *список типов аргументов*.

Дополнительно могут быть заданы *имена аргументов*. Они не являются частью *сигнатуры функции* и могут отличаться от объявления к объявлению (или определению).

## 2.2. Передача аргументов

### 2.2.1. Аргументы-ссылки

Аргументы, представляющие собой **константную ссылку `const T&`**, могут принимать литералы, константы, переменные. Они также разрешают выполнение *преобразования типа* для фактического параметра - в этом случае перед вызовом функции будет создана *временная переменная* с временем жизни константной ссылки (т.е. до завершения функции).

Аргументы, представляющие собой обычную **ссылку `T&`** могут принимать только переменные, причем *преобразование типа* фактического параметра ЗАПРЕЩЕНО!

### 2.2.2. Аргументы-массивы

При передаче массива `T[]` в аргуент функции он всегда преобразуется в указатель на свой первый элемент `T*` - массив не может быть передан по значению.

## 2.3. Возвращение значения

Функция должна либо возвращать значение указанного типа `T` (для которого при необходимости выполняется *преобразование типа*), либо НЕ возвращать ничего, если она объявлена как `void`.

Функция, ВОЗВРАЩАЮЩАЯ значения, может полностью завершиться, так и не вызвав `return` - это называется **выпадением из функции**. Выпадение не запрещено компилятором и не вызывает ошибку времени выполнения, однако значения возвращаемого значения НЕ определено. Выпадение гарантированно приводит к ошибкам логики программы и НЕ должно в ней присутствовать.

Функция НЕ должна возвращать указатель либо ссылку на локальную переменную, уничтожаемую при завершении функции - это гарантированно приводит к ошибкам логики.

## 2.4. Перегрузка функций

**Перегрузка функции** - использование единственного имени функции для объявления (определения) нескольких функций различного типов (на жаргоне их называю *перегрузками*). Данный механизм применяется при необходимости специфицировать поведение функции в зависимости от типов принимаемых ею аргументов.

На этапе компиляции для каждого места вызова перегруженной функции выполняется поиск такой её перегрузки, формальные параметры которой будут *наилучшим образом* соответствовать фактическим параметрам данного вызова. Определен следующий приоритет соответствий типов для заданного аргумента функции:

1. Точное соответствие типов или соответствие, полученное *тривиальным преобразованием типов*: `T[] -> T*`, `T <-> cont T`, функция в указатель на функцию;
2. Cоответствие, полученное *продвижением типов*: интегральным (`char -> int` и т.д.) или вещественным (`float -> double`);
3. Cоответствие, полученное *cтандартным преобразованием типов*: `int <-> double` и т.д. (допускаются *сужающие преобразования*), `Derived* -> Base*`, `T* -> void*`, `signed ints -> unsigned ints`;
4. Cоответствие, полученное *определенным пользователем преобразованием*: конструкторы и операторы преобразования;
5. Соответствие за счет многоточия `...` в объявлении функции.

Наиболее подходящей перегрузкой является та, все формальные аргументы которой соответствуют фактическим аргументам вызова, и при этом *минимальный из уровней соответствия* имеет СТРОГО наибольшее значение среди остальных перегрузок. Если найдено несколько перегрузок с одинаковым минимальным уровнем соответствия, то вызов считается **неоднозначным** - происходит *ошибка компиляции*.

При разрешении перегрузки поиск выполняется только среди ОБЪЯВЛЕННЫХ К МОМЕНТУ вызова перегрузок. Порядок объявлений значения НЕ имеет.

Механизм разрешения перегрузки *НЕ пересекает границы областей видимости*. В разрешении перегрузки данного вызова НЕ участвуют перегрузки, объявленные в других областях видимости:

+ в других блоках кода (в случае вложенных блоков внутреннее имя будет скрывать внешнее имя);
+ в других пространствах имен;
+ в *родительских* по отношению к данному классах.

Чтобы ввести имя функции в текущую область видимости, позволить обращаться к ней без явного указания *квалификатора* `::` и тем самым разрешить ей участвовать в механизме разрешения перегрузки можно использовать `using`-директиву или `using`-объявление.

*Тип возвращаемого значения функции* при разрешении перегрузки НЕ учитываются - перегрузки одной функции могут иметь различный возвращаемый тип.

## 2.5. Спецификатор inline

**Спецификатор `inline`** указывает компилятору, что для функция явялется *встроенной* - для неё будет использоваться **внутреннее связывание**, однако компилятор самостоятельно решает, генерировать ли в каждом месте вызова функции её код, либо применять стандартный механизм вызова. Встроенная функция всё равно имеет свой собственный *уникальный адрес* в памяти процесса.

# 3. Пространства имен

## 3.1. `using`: объявления и директивы

**using-объявление для функции** вводит имя функции в текущую область видимости (*блок кода, класс или пространство имен*) и делает его доступным для использования без указания квалификатора `::`. Существуют следующие правила введения имени функции в область видимости:

+ в *блок кода* может быть введено имя функции из другого пространства имен;
+ в пространство имен может быть введено имя функции из другого (включая *охватывающее*) пространства имен;
+ в класс может быть введено имя функции из *родительского класса*; при этом данное имя изначально должно быть видно в дочернем классе (в дочернем классе не видна `private` секция родительского класса);

using-объявления имеют следующий вид:

```Cpp
using MyNamespace::myFunc;
using BaseClass::myFunc;
```

**using-директива** вводит имена *сущностей* указанного *пространства имен* в текущую область видимости (*блок кода или пространство имен*) и делает их доступными для использования без указания квалификатора `::`.

using-директива имеет следующий вид:

```Cpp
using namespace MyNamespace;
```

Имена, напрямую *объявленные в текущей области видимости* или введенные *using-объявлением*, **СКРЫВАЮТ** имена, введенные *using-директивой*. Это позволяет, например, объединить с помощью директив несколько пространств в одном, а затем устранить все проявившиеся конфликты имен через using-объявления.

Наиболее часто using-объявления и using-директивы импользуется, чтобы позволить введенной функции участвовать в механизме разрешения перегрузки, а также чтобы при каждом использовании имени не указывать квалификатор (например, если он длинный).

## 3.2. Поиск  имени функции

Если функция, объявленная в пространстве имен, вызывается в некоторой области видимости без указания *квалификатора своего пространства имен* `::` (и при этом она не была введена в текущую область через `using`), то поиск её объявления осуществляется в пространствах имен её аргументов. Это вызвано тем, что зачастую функции, принимающие пользовательские типы `class T`, определяется в тех же самых пространствах имен, что и эти пользовательские типы. При этом пространство имен должно быть видимым в данной области видимости, а объявление функции в нем должно существовать - правило, что имя (функции) должно быть объявлено до своего использования, никто не отменял!

# 4. Компоновка

Про имя сущности, доступное для использования только в той единице трансляции, в которой эта сущность определена, говорят, что оно **компонуется внутренним образом (internal linkage)**.

Про имя сущности, доступное для использования в различных единицах трансляции, отличных от той, в которой эта сущность определена, говорят, что оно **компонуется внешним образом (external linkage)**.

Следующие сущности, объявленные в глобальной области видимости или в пространстве имен, компонуются *внутренним образом*:

+ константы `const`;
+ выражения создания пседонимов `typedef`;
+ встроенные `inline` функции;

## 4.1. Правило одного определения (ODR)

Любая сущность должна быть *определена* в программе *ровно один раз*. Однако несколько определений *класса, шаблона или встроенной функции* могут существовать в качестве определения одной и той же сущности, если:

+ они находятся в различных единицах трансляции;
+ они идентичны лексема за лексемой (они записаны одинаково);
+ значение лексем идентично во всех единицах трансляции (их смысл одинаков).
